# 计算机组成原理

The principles of computer composition

## 计算机系统概述

### 计算机系统层次结构

#### 计算机硬件

冯诺依曼机

* 五大部件
* 指令和数据
* 二进制
* 指令=操作码+地址码
* 存储程序
* 运算器为中心

现代计算机

* 以存储器为中心
* CPU=运算器+控制器
* 主机=CPU+主存储器(内存?)
* I/O设备:输入设备,输出设备,辅存储器(磁盘?)

主存储器的部件

* 存储体:存储单元一般是8位的整数倍;存储元存1位;存储字长代表存储单元的代码的位数
* MAR:存储地址寄存器;代表存储单元的个数,$4位=2^4个存储单元$
* MDR:存储数据寄存器;代表存储字长

澄清

* 100Mbps:ps代表per second每秒钟;100M代表100M个;b代表比特位
* 12.5MB/s:12.5M代表12.5M个;B代表字节
* 区分B(字节)和b(比特位bit)
* 1B=8bit

运算器的部件

* ACC:累加器;存放操作数或运算结果
* MQ:乘商寄存器;存放操作数或运算结果(乘除法时)
* X:通用操作数寄存器;存放操作数
* ALU:算数逻辑单元;实现算数运算和逻辑运算
* 标志寄存器,这个在图上有专门画出

控制器的部件

* CU:控制单元;分析指令,给出控制信号
* IR:指令寄存器;存放当前执行指令
* PC:程序计数器;存放下一条执行指令;自动加1

指令三步骤

* 取指
  * (PC) -> MAR
  * M(MAR) -> MDR
  * (MDR) -> IR
  * (PC)+1 -> PC
* 分析
  * OP(IR) -> CU
* 执行
* 题目中系列机的指令系统向后兼容,指的是时间上的向后兼容,即老机器开发的程序在新机器也能兼容使用

存取速度对比

* 寄存器>Cache>内存

相联存储器

* 既可以按照地址寻址,又可以按照内容寻址,详见第三章

三个字长

* 机器字长:等于CPU内部数据通路的宽度(例如通用寄存器宽度,例如ALU);和运算精确度密切相关
* 存储字长:一个存储单元中的位数,即MDR位数
* 指令字长:取决于指令的功能和格式

#### 计算机软件

翻译程序

* 编译器:可以翻译成汇编语言或者机器级目标代码文件
* 汇编器
* 解释器
* 机器级目标代码文件,可以理解为C语言的.o文件

语言级别

* 高级语言
* 汇编语言
* 机器语言

指令集体系结构

* ISA;软件和硬件之间的界限,即一台计算机应该能够支持哪些指令

#### 计算机系统的层次结构

以编程人员视角来看层次结构

* 虚拟机器 M4:高级语言;
* 虚拟机器 M3:汇编语言;一条汇编语言指令和机器语言指令是一一对应的
* 虚拟机器 M2:操作系统;向上提供系统调用指令
* 传统机器 M1:机器语言;执行二进制指令;一条二进制指令可能包含多个微指令步骤
* 微程序机器 M0:微指令系统;硬件直接执行微指令
* 重点关注M0和M1;具体指令的实现;对程序员透明(看不见)

#### 计算机系统工作原理

C语言源程序流程

* .c的源代码文件
* 经过预处理器,例如宏定义常量替换,得到.i源文件
* 经过编译器,得到.s汇编文件
* 经过汇编器,得到目标模块.o
* 经过链接器,链接其他.o目标模块,得到可执行文件.exe

### 计算机的性能指标

#### 主要性能指标

存储器总容量

* MAR有32位,MDR是8位,则总容量为$2^32*8 bit$
* MAR表示最多支持多少个存储单元
* MDR的位数就是存储字长

CPU主频和时钟周期

* CPU主频:指的是CPU内数字脉冲信号振荡的频率;单位Hz赫兹;一秒钟内时钟周期的数量
* 时钟周期:最小时间单位,每个指令至少需要一个时钟周期;单位s秒
* $CPU主频= \frac{1}{CPU时钟周期}$
* CPI和平均CPI:执行一条指令需要多少个时钟周期;时钟频率不会影响到CPI
* 执行指令的耗时为$CPI \times CPU时钟周期$
* CPU执行时间:$时钟周期数 \times 时钟周期长度$;$CPI \times 指令条数 \times 时钟周期长度$
* IPS:每秒执行多少条指令;$IPS= \frac{主频}{CPI}$;单位KIPS等,K代表数量千
* FLOPS:每秒执行多少次浮点数运算;单位KFLOPS等,K代表数量千;科学计算的性能参数指标

CPI相关

* 系统结构:硬件影响
* 计算机组织:硬件影响
* 指令集:影响到程序的指令条数,从而影响CPI

系统整体性能指标

* 数据通路带宽:指的是数据总线一次性所能够并行传送的信息的位数
* 吞吐量:单位时间内处理请求的数量;用户观点来看的性能参数指标
* 响应时间:指用户发出一个操作请求,计算机对该请求作出响应并获取结果整体的响应时间
* 基准程序:跑分软件

数量单位

* 描述存储容量,文件大小时:$K=2^{10}$, $M=2^{20}$, $G=2^{30}$, $T=2^{40}$
* 描述频率,速率时:$K=10^3$, $M=10^6$, $G=10^9$, $T=10^{12}$

改善性能

* CPU主频
* 并行处理
* 优化代码,减少时钟周期数
* 减少访问内存时间

## 数据的表示和运算

### 数制与编码

#### 进位计数制

概念

* 基数:r进制的基数就是r
* 常见二进制,八进制,十六进制,十进制
* 二进制:基数0,1;以B结尾表示
* 八进制:基数0,1,2,3,4,5,6,7;以O结尾表示
* 十六进制:基数0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F;以H结尾表示,或者以0x开头表示
* 十进制:基数0,1,2,3,4,5,6,7,8,9;以D结尾表示

进制转换

* 其他进制转换成十进制:小数部分从-1次方开始,基数r,位权
* 十进制转换成其他进制:整数部分除r取余法,小数部分乘r取整法(小数部分有可能无限循环);转换成其他进制可以先转换成二进制
* 二进制转换成八进制:3位一组,整数部分前面补0,小数部分后面补0;然后按照4,2,1的位权进行转换
* 二进制转换成十六进制:4位一组,整数部分前面补0,小数部分后面补0;然后按照8,4,2,1的位权进行转换
* 八进制转换成二进制:每一位都转换成3位的二进制数
* 十六进制转换成二进制:每一位都转换成4位的二进制数

真值和机器数

* 真值:带有正负号的实际数字
* 机器数:数字存储在机器里面的形式

#### 定点数的编码表示

概念

* 定点数:小数位数固定
* 浮点数:小数的位数不固定;科学计数法

定点数的表示

* 无符号数:没有正负;表示的范围取决于用几位二进制来表示,例如8位二进制数
  * n位的表示范围是$[0,2^{n}-1]$
  * 只有无符号整数,没有无符号小数
  * 无符号数没有原反补移码的概念
* 有符号数:分为定点整数和定点小数
  * 可以使用原码反码补码来表示;也可以用移码来表示定点整数
  * 定点整数:最高位表示符号位
  * 定点小数:最高位表示符号位
  * 符号位一般使用0代表正,1代表负
  * 小数点不占bit位置,是隐含在固定位置上
* 原码:和无符号数的表示一样,但是带符号位
  * 原码整数:n位的表示范围是$[-(2^{n-1}-1),2^{n-1}-1]$
  * 这里真值0有+0和-0
  * 原码小数:$n+1$位的表示范围是$[-(1-2^{-n}),1-2^{-n}]$
  * 例如8位原码能表示的不同数据有$2^8-1=255$(因为0有两种表示)
* 反码:正数的反码就是原码本身,负数的反码是原码按照位置进行取反(除了符号位);整数和小数一样的规则
  * 表示范围和原码一样
  * 例如8位反码能表示的不同数据有$2^8-1=255$(因为0有两种表示)
* 补码:正数的补码就是原码本身,负数的补码是反码+1,需要考虑进位
  * 从补码求原码的过程,也是取反+1
  * 补码整数表示范围$[-2^{n-1},2^{n-1}-1]$
  * 补码小数表示范围$[-1,1-2^{-n}]$
  * 从$x$的补码求解$-x$的补码:符号位,数值位全部取反,末位+1
  * 例如8位补码能表示的不同数据有$2^8=256$(0只有一种表示)
* 移码:在补码的基础上,将符号位取反
  * 只能表示整数
  * 移码的真值0也只有一种表示形式即1000 0000
  * 表示范围和补码一致
  * 例如8位移码能表示的不同数据有$2^8=256$(0只有一种表示)
  * 作用是对比大小,从最高位开始比较,谁先出现1谁大,一直比较到最后

补码真值0的问题

* 这里单独说一下补码的真值0里面的-0的情况:
* 由于-0的原码是1000 0000,而反码是1111 1111,此时补码+1,发生溢出,即1 0000 0000,舍弃溢出位后,剩余0000 0000,和+0的补码重复
* 这意味着补码的真值0只有一种表示形式就是0000 0000
* 那么自然多出一个位置即1000 0000,所以规定补码1000 0000代表$-2^7 = -128$
* 同理,补码小数也多了一个位置就是1.000 0000,代表-1

附图

![alt text](image.png)

![alt text](image-1.png)

各种码的作用

无符号数

* 可以表示主存地址

补码实现加减法

* 数论中余数定义$x=qm+r,0<=r<m$,q是整数
* 补数:找到负数的补数,让减法变成加法
  * 补数的求解方法是$模-a的绝对值=a的补数$,这里的模就是$2^8$,以$8bit$为例
  * 补数实际上就是补码
* 补码的作用就是让减法变成加法,ALU无需实现减法器,节省硬件成本;得到的结果也是补码
* 符号位一起参加运算

移码来判断数据大小

补码的位权

* 符号位理解为$-2^n$的位权,然后运算的时候将补码的符号位也参与运算,求解真值;如果符号位是0,那也成立(因为0乘以$-2^n$还是0)

补码和真值

* 补码和真值的表示是一一对应的
* 这意味着补码如果相同,真值的表示也相同;反之亦然

移码的偏置值

* 移码等于真值加上偏置值,默认的偏置值设置为$2^{n-1}$
  * 即$x_{真值}=[x_{移码}]-偏置值$
* 做计算时,把移码理解为普通二进制数(即不考虑符号位的概念)
* 补码符号位取反,实际上就是偏置值默认的情况

#### C语言的整数类型

强制类型转换

* C语言的定点整数都是使用补码存储
* 当发生强制类型转换时,有如下规则
  * 无符号数和有符号数转换,不改变补码本身,只改变解释方式
  * 长整数变成短整数时,直接高位截断,保留低位
  * 短整数变成长整数时,扩展,补码补1,这代表不会改变真值

数据扩展

* 机器字长一般是固定的,但是内存中(代码中)可能存在多种长度的数据
* 两种方法把短数据扩展为长数据:零扩展;符号扩展
* 零扩展:高位补0,适用于无符号整数
* 符号扩展:符号位和数值位不变,多余补1,适用于有符号整数
