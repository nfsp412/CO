# 计算机组成原理

The principles of computer composition

## 计算机系统概述

### 计算机系统层次结构

#### 计算机硬件

冯诺依曼机

* 五大部件
* 指令和数据
* 二进制
* 指令=操作码+地址码
* 存储程序
* 运算器为中心

现代计算机

* 以存储器为中心
* CPU=运算器+控制器
* 主机=CPU+主存储器(内存?)
* I/O设备:输入设备,输出设备,辅存储器(磁盘?)

主存储器的部件

* 存储体:存储单元一般是8位的整数倍;存储元存1位;存储字长代表存储单元的代码的位数
* MAR:存储地址寄存器;代表存储单元的个数,$4位=2^4个存储单元$
* MDR:存储数据寄存器;代表存储字长

澄清

* 100Mbps:ps代表per second每秒钟;100M代表100M个;b代表比特位
* 12.5MB/s:12.5M代表12.5M个;B代表字节
* 区分B(字节)和b(比特位bit)
* 1B=8bit

运算器的部件

* ACC:累加器;存放操作数或运算结果
* MQ:乘商寄存器;存放操作数或运算结果(乘除法时)
* X:通用操作数寄存器;存放操作数
* ALU:算数逻辑单元;实现算数运算和逻辑运算
* 标志寄存器,这个在图上有专门画出,FR

控制器的部件

* CU:控制单元;分析指令,给出控制信号
* IR:指令寄存器;存放当前执行指令
* PC:程序计数器;存放下一条执行指令;自动加1

指令三步骤

* 取指
  * (PC) -> MAR
  * M(MAR) -> MDR
  * (MDR) -> IR
  * (PC)+1 -> PC
* 分析
  * OP(IR) -> CU
* 执行
* 题目中系列机的指令系统向后兼容,指的是时间上的向后兼容,即老机器开发的程序在新机器也能兼容使用

存取速度对比

* 寄存器>Cache>内存

相联存储器

* 既可以按照地址寻址,又可以按照内容寻址,详见第三章

三个字长

* 机器字长:等于CPU内部数据通路的宽度(例如通用寄存器宽度,例如ALU);和运算精确度密切相关
* 存储字长:一个存储单元中的位数,即MDR位数
* 指令字长:取决于指令的功能和格式

#### 计算机软件

翻译程序

* 编译器:可以翻译成汇编语言或者机器级目标代码文件
* 汇编器
* 解释器
* 机器级目标代码文件,可以理解为C语言的.o文件

语言级别

* 高级语言
* 汇编语言
* 机器语言

指令集体系结构

* ISA;软件和硬件之间的界限,即一台计算机应该能够支持哪些指令

#### 计算机系统的层次结构

以编程人员视角来看层次结构

* 虚拟机器 M4:高级语言;
* 虚拟机器 M3:汇编语言;一条汇编语言指令和机器语言指令是一一对应的
* 虚拟机器 M2:操作系统;向上提供系统调用指令
* 传统机器 M1:机器语言;执行二进制指令;一条二进制指令可能包含多个微指令步骤
* 微程序机器 M0:微指令系统;硬件直接执行微指令
* 重点关注M0和M1;具体指令的实现;对程序员透明(看不见)

#### 计算机系统工作原理

C语言源程序流程

* .c的源代码文件
* 经过预处理器,例如宏定义常量替换,得到.i源文件
* 经过编译器,得到.s汇编文件
* 经过汇编器,得到目标模块.o
* 经过链接器,链接其他.o目标模块,得到可执行文件.exe

### 计算机的性能指标

#### 主要性能指标

存储器总容量

* MAR有32位,MDR是8位,则总容量为$2^32*8 bit$
* MAR表示最多支持多少个存储单元
* MDR的位数就是存储字长

CPU主频和时钟周期

* CPU主频:指的是CPU内数字脉冲信号振荡的频率;单位Hz赫兹;一秒钟内时钟周期的数量
* 时钟周期:最小时间单位,每个指令至少需要一个时钟周期;单位s秒
* $CPU主频= \frac{1}{CPU时钟周期}$
* CPI和平均CPI:执行一条指令需要多少个时钟周期;时钟频率不会影响到CPI
* 执行指令的耗时为$CPI \times CPU时钟周期$
* CPU执行时间:$时钟周期数 \times 时钟周期长度$;$CPI \times 指令条数 \times 时钟周期长度$
* IPS:每秒执行多少条指令;$IPS= \frac{主频}{CPI}$;单位KIPS等,K代表数量千
* FLOPS:每秒执行多少次浮点数运算;单位KFLOPS等,K代表数量千;科学计算的性能参数指标

CPI相关

* 系统结构:硬件影响
* 计算机组织:硬件影响
* 指令集:影响到程序的指令条数,从而影响CPI

系统整体性能指标

* 数据通路带宽:指的是数据总线一次性所能够并行传送的信息的位数
* 吞吐量:单位时间内处理请求的数量;用户观点来看的性能参数指标
* 响应时间:指用户发出一个操作请求,计算机对该请求作出响应并获取结果整体的响应时间
* 基准程序:跑分软件

数量单位

* 描述存储容量,文件大小时:$K=2^{10}$, $M=2^{20}$, $G=2^{30}$, $T=2^{40}$
* 描述频率,速率时:$K=10^3$, $M=10^6$, $G=10^9$, $T=10^{12}$

改善性能

* CPU主频
* 并行处理
* 优化代码,减少时钟周期数
* 减少访问内存时间

## 数据的表示和运算

### 数制与编码

#### 进位计数制

概念

* 基数:r进制的基数就是r
* 常见二进制,八进制,十六进制,十进制
* 二进制:基数0,1;以B结尾表示
* 八进制:基数0,1,2,3,4,5,6,7;以O结尾表示
* 十六进制:基数0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F;以H结尾表示,或者以0x开头表示
* 十进制:基数0,1,2,3,4,5,6,7,8,9;以D结尾表示

进制转换

* 其他进制转换成十进制:小数部分从-1次方开始,基数r,位权
* 十进制转换成其他进制:整数部分除r取余法,小数部分乘r取整法(小数部分有可能无限循环);转换成其他进制可以先转换成二进制
* 二进制转换成八进制:3位一组,整数部分前面补0,小数部分后面补0;然后按照4,2,1的位权进行转换
* 二进制转换成十六进制:4位一组,整数部分前面补0,小数部分后面补0;然后按照8,4,2,1的位权进行转换
* 八进制转换成二进制:每一位都转换成3位的二进制数
* 十六进制转换成二进制:每一位都转换成4位的二进制数

真值和机器数

* 真值:带有正负号的实际数字
* 机器数:数字存储在机器里面的形式

#### 定点数的编码表示

概念

* 定点数:小数位数固定
* 浮点数:小数的位数不固定;科学计数法

定点数的表示

* 无符号数:没有正负;表示的范围取决于用几位二进制来表示,例如8位二进制数
  * n位的表示范围是$[0,2^{n}-1]$
  * 只有无符号整数,没有无符号小数
  * 无符号数没有原反补移码的概念
* 有符号数:分为定点整数和定点小数
  * 可以使用原码反码补码来表示;也可以用移码来表示定点整数
  * 定点整数:最高位表示符号位
  * 定点小数:最高位表示符号位
  * 符号位一般使用0代表正,1代表负
  * 小数点不占bit位置,是隐含在固定位置上
* 原码:和无符号数的表示一样,但是带符号位
  * 原码整数:n位的表示范围是$[-(2^{n-1}-1),2^{n-1}-1]$
  * 这里真值0有+0和-0
  * 原码小数:$n+1$位的表示范围是$[-(1-2^{-n}),1-2^{-n}]$
  * 例如8位原码能表示的不同数据有$2^8-1=255$(因为0有两种表示)
* 反码:正数的反码就是原码本身,负数的反码是原码按照位置进行取反(除了符号位);整数和小数一样的规则
  * 表示范围和原码一样
  * 例如8位反码能表示的不同数据有$2^8-1=255$(因为0有两种表示)
* 补码:正数的补码就是原码本身,负数的补码是反码+1,需要考虑进位
  * 从补码求原码的过程,也是取反+1
  * 补码整数表示范围$[-2^{n-1},2^{n-1}-1]$
  * 补码小数表示范围$[-1,1-2^{-n}]$
  * 从$x$的补码求解$-x$的补码:符号位,数值位全部取反,末位+1
  * 例如8位补码能表示的不同数据有$2^8=256$(0只有一种表示)
* 移码:在补码的基础上,将符号位取反
  * 只能表示整数
  * 移码的真值0也只有一种表示形式即1000 0000
  * 表示范围和补码一致
  * 例如8位移码能表示的不同数据有$2^8=256$(0只有一种表示)
  * 作用是对比大小,从最高位开始比较,谁先出现1谁大,一直比较到最后

补码真值0的问题

* 这里单独说一下补码的真值0里面的-0的情况:
* 由于-0的原码是1000 0000,而反码是1111 1111,此时补码+1,发生溢出,即1 0000 0000,舍弃溢出位后,剩余0000 0000,和+0的补码重复
* 这意味着补码的真值0只有一种表示形式就是0000 0000
* 那么自然多出一个位置即1000 0000,所以规定补码1000 0000代表$-2^7 = -128$
* 同理,补码小数也多了一个位置就是1.000 0000,代表-1

附图

![alt text](image.png)

![alt text](image-1.png)

各种码的作用

无符号数

* 可以表示主存地址

补码实现加减法

* 数论中余数定义$x=qm+r,0<=r<m$,q是整数
* 补数:找到负数的补数,让减法变成加法
  * 补数的求解方法是$模-a的绝对值=a的补数$,这里的模就是$2^8$,以$8bit$为例
  * 补数实际上就是补码
* 补码的作用就是让减法变成加法,ALU无需实现减法器,节省硬件成本;得到的结果也是补码
* 符号位一起参加运算
* 由B的补码来求解-B的补码,全部位(包含符号位)取反末尾+1

移码来判断数据大小

补码的位权

* 符号位理解为$-2^n$的位权,然后运算的时候将补码的符号位也参与运算,求解真值;如果符号位是0,那也成立(因为0乘以$-2^n$还是0)

补码和真值

* 补码和真值的表示是一一对应的
* 这意味着补码如果相同,真值的表示也相同;反之亦然

移码的偏置值

* 移码等于真值加上偏置值,默认的偏置值设置为$2^{n-1}$
  * 即$x_{真值}=[x_{移码}]-偏置值$
* 做计算时,把移码理解为普通二进制数(即不考虑符号位的概念)
* 补码符号位取反,实际上就是偏置值默认的情况

十六进制快速求补

* 从十六进制数字的最低位向左找到第一个非0数字
* 该位右侧的0保持不变
* 对于该非0数字,用16减去该数字
* 对于左侧的所有数字,用15减去对应的数字

#### C语言的整数类型

强制类型转换

* C语言的定点整数都是使用补码存储
* 当发生强制类型转换时,有如下规则
  * 无符号数和有符号数转换,不改变补码本身,只改变解释方式
  * 长整数变成短整数时,直接高位截断,保留低位
  * 短整数变成长整数时,根据短整数类型扩展,无符号高位补0,有符号补符号位

数据扩展

* 机器字长一般是固定的,但是内存中(代码中)可能存在多种长度的数据
* 两种方法把短数据扩展为长数据:零扩展;符号扩展
* 零扩展:高位补0,适用于无符号整数
* 符号扩展:符号位和数值位不变,多余补符号位,适用于有符号整数
* 当存在无符号和有符号加减运算时,按照无符号解释最终的运算结果

默认位数

* int 32位(即8字节)
* short 16位(即4字节)
* unsigned指的就是unsigned int 同样是32位

C语言的比较大小

* 通过前者减去后者,判断是否够减

### 运算方法和运算电路

#### 数字电路前置

![alt text](image-11.png)

* 真1假0
* 与或非三种基本运算,和异或,同或,与非,或非等运算
* 与运算
  * 表达式$Y=A \cdot B$
  * 一假即假(一0即0)
  * 与门
  ![alt text](image-2.png)
* 或运算
  * 表达式$Y=A + B$
  * 一真即真(一1即1)
  * 或门
  ![alt text](image-3.png)
* 非运算
  * 表达式$Y= \overline{A}$
  * 真假相反(10相反)
  * 非门
  ![alt text](image-4.png)
* 与非运算
  * 先与再非
  * 表达式$Y= \overline{A \cdot B}$
  * 原本的与运算结果真值表进行非运算取反
  ![alt text](image-5.png)
* 或非运算
  * 先或再非
  * 表达式$Y= \overline{A+B}$
  * 原本的或运算结果真值表进行非运算取反
  ![alt text](image-6.png)
* 异或
  * 两个输入不同,则为1;反之则为0
  * 表达式$Y=A\oplus B= \overline{A} \cdot B + A \cdot \overline{B}$
  * 由基本的与或非门实现
  ![alt text](image-8.png)
  ![alt text](image-9.png)
* 同或
  * 两个输入相同,则为1;反之则为0
  * 就是在异或基础上再进行非运算
  * 表达式$Y=A \bigodot B=\overline{A\oplus B}$
  ![alt text](image-10.png)

补充

* 异或运算,奇数个1则结果为1,偶数个1则结果为0
* 变形画法
![alt text](image-12.png)
* 运算优先级
  * 非>与>或
  * 可以把与类比乘法,或类比加法
  * 小括号也生效,最高优先级
* 离散数学相关公式,简化电路设计
![alt text](image-13.png)

多路选择器

* 多个输入,一个输出,一个控制信号
* 虚线表示,op英文缩写
* 控制信号位数m和输入个数k的关系是$m>=\lceil log_{2}k\rceil$

三态门

* 也是用于控制数据是否能够通过,但是只能拦截一条电路
* 和非门的区别是,非门没有控制信号,只有输入输出
* 有一些多路选择器可能会设置拦截所有电路输入

#### 基本运算部件

半加器

* 使用异或门和与门实现
* 两个输入,一个输出,一个进位
![alt text](image-14.png)

一位全加器FA

* 能够实现1bit位的加法运算
* 输入有三个:输入$A_{i}$,输入$B_{i}$,进位$C_{i-1}$
* 输出有二个:输出$S_{i}$,进位$C_{i}$
* $S_{i}=A_{i} \oplus B_{i} \oplus C_{i-1}$,因为奇数个1相加时结果是1
* $C_{i}=A_{i}B_{i}+(A_{i} \oplus B_{i})C_{i-1}$,因为至少两个1或者一个1一个低位进位1,才能进位1
![alt text](image-15.png)

n位加法器

* 将n个(例如8bit)串接起来构成n位加法器
![alt text](image-16.png)
* 不足之处:前一位的进位输入到后一位的全加器这个过程存在延迟,因为是串行的;行波进位;位数越多越延迟
* 串行进位的并行加法器

并行进位的并行加法器

* 进位信息都是同时产生的(并行),所以几乎无延迟,速度更快
* 只需要关注逻辑功能,不需要关注具体实现

带标志位的加法器

* OF:溢出标志;判断带符号数乘除加减,无符号数乘除是否溢出;1代表溢出0代表没有溢出
  * $OF=C_{n} \oplus C_{n-1}$,实现逻辑见下文
* SF:符号标志;判断带符号数结果正负;1代表负0代表正
  * $SF=S_{n}$,最高位就是补码符号
* ZF:零标志;结果是否为零;1代表结果为零0代表结果不为零
  * $ZF=S_{n}+S_{n-1}...$,仅全部为0时结果才为0,使用或非门实现
* CF:进位借位标志;判断无符号数加减法是否溢出;1代表溢出0代表没有溢出
  * $CF=C_{n} \oplus C_{0}$,实现逻辑见下文

ALU算数逻辑单元

* 作用:实现加减乘除等功能,与或非等功能,求补码,直送等功能;是CPU中运算器的核心;加法器是其核心
* ALU属于组合逻辑电路
* ALU支持k种功能,则控制信号位数$m>= \lceil log_{2}k \rceil$
* 计算机的机器字长,由ALU运算位数决定,所以相等
* 带有标志位,例如上述四种OF,SF,ZF,CF,这些标志位信息送到PSW(程序状态字寄存器)
  * 注意PSW就是FR(标志寄存器)

#### 定点数的移位运算

一图胜千言

![alt text](image-17.png)

#### 定点数的加减运算

* 重点了解补码的加减运算(补码的加减法不需要考虑符号位,符号位也参与运算)
* 两个正数或两个负数补码相加是可能溢出的,需要溢出判断
  * 两个正数相加,可能上溢,上溢变负数;而两个负数相加,可能下溢,下溢变正数
  * 校验方式1(离散数学):$V=A_{S}B_{S} \overline{S_{S}} + \overline{A_{S}B_{S}} S_{S}$,$A_{S}$代表$A$的符号位,$B_{S}$代表$B$的符号位,$S_{S}$代表结果$S$的符号位,$V=0$代表无溢出,$V=1$代表有溢出
  * 校验方式2:符号位的进位$C_{S}$,和最高数值位的进位$C_{1}$,当这两个不同,则代表溢出;使用异或$V=C_{S} \oplus C_{1}$,$V=0$代表无溢出,$V=1$代表有溢出
  * 校验方式3:使用双符号位,同样参与运算,当双符号位是01代表上溢,10代表下溢,相同代表无溢出;使用异或$V=S_{S1} \oplus S_{S2}$,$V=0$代表无溢出,$V=1$代表有溢出

双符号位补码

* 又称为模4补码;对应的单符号位补码,又称为模2补码(常用都是单符号位)
* 01代表上溢(正溢出),10代表下溢(负溢出),相同代表无溢
* 实际存储只存储一个符号位,在运算之前会复制一个符号位,所以没有额外增加存储的空间
* 模4补码具有模2补码的全部优点且更易检查加减运算中的溢出问题

#### 无符号数的加减运算

* 加法略,减法的方式是:参考补码,全部位取反末尾+1,计算后直接得到结果(不需要再转换回去),例如a-b,把b全部位取反末尾加1再和a相加,无需转换回
* 判断溢出的方法
  * 手算:十进制代入计算查看是否超出范围即可
  * 加法:最高位进位为1,代表溢出
  * 减法:最高位进位为0,代表溢出

#### 补码加减运算电路

电路图示意图如下

![alt text](image-18.png)

#### 无符号和有符号的混合

* 当存在无符号和有符号加减运算时,按照无符号解释最终的运算结果

#### 无符号整数的乘法原理

手算原理

* 手算乘法原理(十进制):逐位相乘,错位相加
* 手算乘法原理(二进制):1乘以数等于其本身,0乘以数等于0,然后也是逐位相乘,错位相加规则

电路原理

如图

![alt text](image-19.png)

* 重复n轮加法和移位运算,一直到计数器$C_{n}=0$
  * n代表相乘的数字的位数,X代表被乘数寄存器,触发器C,乘积寄存器P,乘数寄存器Y
  * 步骤1:将乘数寄存器Y的最低位,送到控制逻辑那里进行判断
  * 步骤2:如果最低位是1,则执行加法,运算结果再写回乘积寄存器P,进位信息存储在触发器C
  * 步骤3:如果最低位是0,什么都不做
  * 步骤4:触发器C,乘积寄存器P,乘数寄存器Y,看做整体,逻辑右移一位
  * 步骤5:计数器$C_{n}$减一
* 两个n位无符号整数进行相乘,运算结果使用2n位暂存(最多2n位)
* 很多架构,仅仅保留低位的n位数作为结果,所以结果可能发生溢出
* n位相乘,需要n个时钟,如果一轮处理2位,则时钟优化为一半

溢出判断

* 如果高位的n位数不全为0,代表溢出,设置OF标志位1
* 如果高位的n位数全为0,代表没有溢出,设置OF标志位0
* 溢出的处理:不处理;或者使用溢出自陷指令(例如INTO)来触发执行操作系统的异常处理程序

#### 有符号整数的乘法原理

电路结构和示例

![alt text](image-20.png)

* 相较于无符号整数乘法电路,区别如下
  * 乘数寄存器Y后面还有一个辅助位,辅助位初始化为0
  * 每次读取2位到控制逻辑中
  * 不保存进位信息C
* 详解
  * 不探讨数学原理,只关注工作过程
  * 步骤1:将乘数寄存器Y的最低位,和辅助位,送到控制逻辑那里进行判断
  * 步骤2:如果最低位是0,辅助位是0;或者最低位是1,辅助位是1;什么都不做
  * 步骤3:如果最低位是0,辅助位是1,执行操作P+X
  * 步骤4:如果最低位是1,辅助位是0,执行操作P-X
  * 步骤5:乘积寄存器P,乘数寄存器Y,辅助位,看做整体,算数右移一位
  * 步骤6:计数器$C_{n}$减一
* 同无符号乘法,同样可能溢出
* 补码一位乘法(Booth乘法),指的就是当前的乘法原理

溢出判断

* 如果高位的n+1位数不完全相同,代表溢出,设置OF标志位1
* 如果高位的n+1位数完全相同,代表没有溢出,设置OF标志位0
* 溢出的处理:不处理;或者使用溢出自陷指令(例如INTO)来触发执行操作系统的异常处理程序
* 做题时快速判断溢出的方式:转换成十进制乘除,然后看寄存器位数范围

#### 其他乘法实现方式

* 由ALU,寄存器,移位器,控制逻辑实现乘法
* 阵列乘法器:n位乘法,可以在一个时钟内完成;是快速乘法器的一种
* 用逻辑运算,加减运算等效实现乘法(代码层面实现,可想而知最慢)

补充:原码乘法

* 用于浮点数尾数乘运算
* 积的符号位通过两个符号位异或得到
* 积的数值位使用无符号乘法
* 原码一位乘法:n轮加法右移操作实现
* 原码乘法原理:先取操作数绝对值相乘,符号位单独处理不参与运算

#### 无符号整数的除法原理

手算

* 规则:尽可能接近中间余数,又不能大于中间余数;二进制下,如果中间余数大于除数,则上商1

除法电路

![alt text](image-21.png)

* 以n位无符号整数为例,支持2n位除以n位的除法运算,得到n位商和n位余数
* 初始化时:
  * 将除数放在寄存器Y,将被除数放在寄存器R,Q(RQ看做一个整体)
  * 被除数不够2n位,则进行扩展,零扩展方法(无符号真值不变扩展方法)
  * 计数器$C_{n}$设置为n
* 控制逻辑检查:
  * 除数是否为0,抛出除数为0异常
  * 被除数小于除数时,商等于0,余数等于被除数
* 上商规则:如果$R-Y>=0$,则上商1,否则上商0
  * 注意$R-Y$的结果会写回寄存器R;如果是正数则不需要额外执行一次加Y的加法运算
  * 但是如果是负数,则需要额外执行一次加Y的加法运算,来恢复成R
* 第一轮处理:
  * 特殊,进行商溢出的判断,如果上商1,则发生商溢出异常,停止程序
  * 如果上商0,则不保留该位,$C_{n}$计数器也不进行自减,继续除法运算
* 继续循环处理$n$轮:
  * RQ整体左移1位,高位丢弃,低位上商
  * 上商,背后进行了加/减法(R和Y的加/减法);写使能到低位;注意上商规则
  * 计数器$C_{n}--$,当计数器为0时,除法运算结束
* 叫做恢复余数法,还有一种不恢复余数法,但难以理解
* 对于做题来说:求解最终状态的R和Q,只需要按照十进制求出R和Q,然后转换成二进制即可

双精度单精度除法

* 2n位除以n位就是双精度
* n位除以n位就是单精度
* 最终都是保留n位余数,n位商
* 无符号整数双精度除法可能商溢出,但是无符号整数单精度除法不可能商溢出

## 第三章.存储系统

### 3.1.存储器概述

#### 存储器层次结构

![alt text](image-22.png)

* 主存和Cache之间的数据交换,由硬件完成,解决主存和CPU速度不匹配问题
* 主存和辅存之间的数据交换,由操作系统的页面置换算法实现,实现了虚拟存储系统,解决主存容量不足问题

#### 存储器分类

* 按照存储介质
  * 半导体存储
  * 磁表面存储
  * 光存储
* 按照存取方式:
  * 随机存取存储器(RAM),读取时间和物理位置无关;按照地址访问;RAM,ROM;注意这两个RAM不是同一个RAM
  * 顺序存取存储器(SAM),读取时间取决于物理位置;串行访问;按照地址访问;磁带
  * 直接存取存储器(DAM),包含随机读取和顺序读取的性质;串行访问;按照地址访问;磁盘,光盘
  * 相联存储器(CAM),根据内容查找位置;按照内容访问;快表就是一种CAM
* 按照信息的可更改性质:
  * 可读可写的
  * 只读的(ROM),例如BIOS通常写在ROM中
* 按照信息的可保存性质:
  * 易失性存储器;断电后数据消失;主存RAM,Cache
  * 非易失性存储器;磁盘,光盘,ROM等
* 按照信息是否被破坏:
  * 破坏性读取;读取数据后原本数据被破坏;DRAM(动态RAM)
  * 非破坏性读取;SRAM(静态RAM),磁盘,光盘

#### 存储器的性能指标

* 存储容量:$存储字长 \times 字长$,例如1M×8位,存储字长由MDR位数反映
* 单位成本
* 存储速度:$数据传输率(主存带宽)=\frac{数据宽度}{存储周期}$
  * 数据宽度指的就是存储字长
  * 半字:指的是数据宽度(存储字长)的一半
  * 存储周期等于存取时间加恢复时间

#### 题目相关

* 编址:如何给地址空间分配唯一地址,默认按照字节编址
* 寻址:如何给出相应的地址;例如按半字寻址,指的是2B(如果存储字长是32位)
* 寻址单元数量:等于存储器的容量除以不同的寻址方式所对应的单个地址单元长度
* 现代计算机存储字长可以不等于机器字长,但是考试中一般是相等的
* 相联存储器是按照内容指定方式和地址指定方式相结合进行寻址的(因为有一些混合结构的也能够按照地址方式)
* Cache命中率:同时访问Cache和主存时
  * x代表Cache命中率
  * 以选择题为例:$100x+1000(1-x)<=115$
* ROM分类
![alt text](image-23.png)
* CD-ROM虽然带一个ROM,只是表示了只读特性,并不属于半导体存储器,而是属于光存储器,所以也没有随机存取特性
